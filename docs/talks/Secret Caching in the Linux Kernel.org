#+TITLE: Secret Caching in the Linux Kernel: key resolution
#+AUTHOR: hex
#+EMAIL: hex@neg9.org
#+name: begin_slide_deck
#+headers: :exports none :results output silent 
#+begin_src emacs-lisp
  (org-display-inline-images t)
  (org-hide-src-block-by-name "fig:request-key")
  (let ((newbuf (concat (buffer-name) "-overview")))
    (ignore-errors (kill-buffer newbuf)
                   (with-selected-frame
                       (new-frame '((name . "overview")))
                     (progn
                       (make-indirect-buffer (buffer-name)
                                             newbuf))
                       (switch-to-buffer newbuf)
                       (org-mode))))
  (ignore-errors (kill-buffer (concat (buffer-name) "*eshell*")))
  (with-selected-frame (new-frame '((name . "shell"))) (eshell))
  (ignore-errors (kill-buffer (concat (buffer-name) "syslog")))
  (with-selected-frame (new-frame '((name . "syslog"))) (progn
                                                          (let ((eshell-buffer-name "syslog"))
                                                            (eshell))
                                                          (insert "journalctl -f")
                                                          (eshell-send-input)))
  (org-tree-slide-mode)
#+end_src

* COMMENT outline notes
** COMMENT read before starting talk
<f8> start
M-x org-tree-slide-presentation-profile
fwd and back are C-> C-<
C-> org-tree-slide-move-next-tree

use M-x org-tree-slide-presentation-profile

org-tree-slide-slip-outline-level

C-x C-+, C-x C-- resize font

for questions, repeat question for recording
** COMMENT helper functions
#+name: run_in_eshell
#+headers: :var cmd="ls"
#+BEGIN_SRC emacs-lisp :results none
    (with-current-buffer "*eshell*"
      (eshell-return-to-prompt)
      (eshell-reset)
      (insert cmd)
      (eshell-send-input))
#+END_SRC

** COMMENT Outline (should I fuck off now?)
The most important thing I want to know at the beginning of any talk
is, "can I get a beer/smoke/etc"? As a presenter, "can I use this time
to work on my talk instead of listen to this asshole ramble on?" 
*** COMMENT not a normal slide deck
**** COMMENT all in emcas
**** COMMENT not actually digging in to the kernel
Should be called "Secret Caching in the Linux Kernel: key resolution"
next preso "Secret Caching in the Linux Kernel 2: ecryptfs is kind of shitty"

My original deck was all tracing through the kernel, this is mostly
userland.
***** For a deeper dive, I will post this talk later
**** COMMENT not a complete solution
Goodspeed "share unfinished research..."
*** COMMENT not a bug, but a fix talk
kind of a hard talk in some ways "Oh look! look at how this code is
working exactly as it's supposed to! Look how not owned this is!" 
** COMMENT history
*** COMMENT why was I doing this research
**** COMMENT Problem
Standard key storage problem
***** COMMENT  When does this happen?
Every linux box ever
- certs
- keys
  - encryption
  - signing
- DB credentials
- Framework secrets
  - Rails
  - Flask (used to pickle)
  - etc.
- AWS creds
- etc.
***** COMMENT Solved elsewhere
****** COMMENT What would a solution look like?
A solution must require code execution in order to recover either
encrypted data or a key to encrypt data. 
******* COMMENT DPAPI (Windows)
(win7 AES256+SHA512 PBKDF2[login creds]*5600)
******** COMMENT CryptProtectData
[[https://msdn.microsoft.com/en-us/library/windows/desktop/aa380261(v=vs.85).aspx]]
BOOL WINAPI CryptProtectData(
  _In_       DATA_BLOB                 *pDataIn,
  _In_opt_   LPCWSTR                   szDataDescr,
  _In_opt_   DATA_BLOB                 *pOptionalEntropy,
  _Reserved_ PVOID                     pvReserved,
  _In_opt_   CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct,
  _In_       DWORD                     dwFlags,
  _Out_      DATA_BLOB                 *pDataOut
);
******** COMMENT CryptUnprotectData
[[https://msdn.microsoft.com/en-us/library/windows/desktop/aa380882(v=vs.85).aspx]]
BOOL WINAPI CryptUnprotectData(
  _In_       DATA_BLOB                 *pDataIn,
  _Out_opt_  LPWSTR                    *ppszDataDescr,
  _In_opt_   DATA_BLOB                 *pOptionalEntropy,
  _Reserved_ PVOID                     pvReserved,
  _In_opt_   CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct,
  _In_       DWORD                     dwFlags,
  _Out_      DATA_BLOB                 *pDataOut
);
******* COMMENT OSX Keychain API
(I don't actually care... Gibson don't run OSX) (...actually sometimes it does)
https://developer.apple.com/library/mac/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html
******* COMMENT Other solutions
******** COMMENT some DE specific linux stuff (which sucks) 
******** COMMENT KMS (AWS)
Awesome! Basically a cross platform distributed DPAPI. But KMS does
not cache, so a CGI application would need to make one (web) request
to decrypt secrets for each call to it.
***** COMMENT No one has solved this problem for linux
This bug has been around forever, and seems pretty easy to fix. I
finally realized I'm the lazy asshole who's not fixed it yet.
*** COMMENT what is keyctl
Kernel key retention service introduced in 2004.
**** COMMENT also supports
- selinux contexts (which allows other cool stuff)
- user_namespaces (apparenlty)
**** COMMENT why
- kerb keys (cifs.spnego)
- environment verification (evm) via TPM
- encrypted FS keys (ecryptfs specifically)
- id resolution in NFS
- generic secrets cache
** COMMENT userland interaction
# end @30 min or so
switch to the elsip buffer to demo interaction
*** COMMENT turn on debugging
#+BEGIN_SRC sh :session syslog
journalctl -f&
#+END_SRC

#+RESULTS:
: [1] 4855

*** COMMENT keyctl (command line) examples
:PROPERTIES:
:session: "*eshell*"
:END:

**** show keys
#+call: show_keys[:session "*eshell*"]()

#+RESULTS:
: Session Keyring
:  621324351 --alswrv   1000 65534  keyring: _uid_ses.1000
:  159171813 --alswrv   1000 65534   \_ keyring: _uid.1000
:  194043442 --alswrv   1000  1000   |   \_ user: custom:display
:  189504584 --alswrv   1000  1000   \_ user: debug:demo
:  767687208 --alswrv   1000  1000   \_ user: debug:fail:2

**** add keys
#+call: add_key[:session "*eshell*"]()

#+RESULTS:
|                                                                                                                   |
| > > [hex@wpad Secret Caching in the Linux Kernel]$ > > > [hex@wpad Secret Caching in the Linux Kernel]$ 248398886 |

**** show data in key
#+call: print_key[:session "*eshell*"]()

#+RESULTS:
: 
: > > [hex@wpad Secret Caching in the Linux Kernel]$ keyctl_read_alloc: Required key not available


**** delete key
#+call: del_key[:session "*eshell*"]()

#+RESULTS:
|                                                                    |
| > > [hex@wpad Secret Caching in the Linux Kernel]$ 0 links removed |

**** resolve a key
#+call: resolve_key[:session "*eshell*"]()

**** what else?
#+name: keyctl_functions
#+begin_src sh :results verbatim drawer
  keyctl 2>&1 | grep keyctl | cut -f4- -d' ' | grep -v -- --version
#+end_src

*** COMMENT how the resolution system works
- User code calls request_key function
(supposed to be request-key, but ditaa is fucked up and I haven't switched to ascidia yet)
** COMMENT writing resolvers
*** COMMENT debugging a resolver
**** COMMENT fail resolver
keyctl request2 user fail:1 spoon
***** will fail, show journalctl -f in eshell
keyctl request2 user fail:2 spoon
#+call: resolve_key[:session "*eshell*"](DESCRIP="fail:2" DATA="spoon")

***** make if fail
#+name: fail_request_noexec
#+headers: :session sudo
#+begin_src sh
  sudo chmod -x /usr/local/sbin/failing_resolver
#+end_src
***** add line for requestkey
***** run it
***** fix perms
#+name: fail_request_exec
#+headers: :session sudo
#+begin_src sh
  sudo chmod +x /usr/local/sbin/failing_resolver
#+end_src

***** note 
requests are cached, so "fail:1" will still fail after fixing
**** COMMENT add to request_key
[[/sudo:root@localhost:/etc/request-key.conf][/etc/request-key.conf]]
#+begin_example

#+end_example
***** TODO add journctl command
***** TODO add command for running key
#+call: resolve_key[:session "*eshell*"](DESCRIP="fail:2" DATA="spoon")
**** COMMENT run tests
#+call: make_static_key[:cache yes](ID="debug:foobarbaz")

#+RESULTS:
: 607948424

#+call: del_key(KEYNUM=make_static_key(ID="debug:foobarbaz"))

#+RESULTS:
: 2 links removed

**** COMMENT check the log
[[/tmp/request-key-debug.log]]
*** COMMENT  hello world

*** COMMENT hello world in python
lets skip this
*** COMMENT stored resolver
Initial goal of my research was look for or see how difficult it would
be to build DPAPI for Linux. Now we have the first building block.
**** goals
***** stored key that's randomly generated if it doesn't exist
***** protect key from user
***** encrypt and decrypt functions
**** achieved
***** randomly generated key
***** persistent across reboots
***** accessible only through code exec, not by read
*** COMMENT chained resolver
%{<type>:<description>}
[[file:/sudo:root@localhost:/etc/request-key.conf::create%20user%20custom:url_to_passwd:*%20*%20|/usr/local/bin/pwsafe_url_pw_resolver.py%20%25u%20%25g%20%25T%20custom:pwsafe_key:url][done here]]
*** COMMENT KMS resolver
I'm going to cheat (and I can't demo this right now). 
**** if we can do local store, we can do anything
If it's possible to use a local key store, there's nothing that stops
a resolver from using any arbitrary keystore.
***** kms stores keys in cloud
Amazon - Key Management System ~$5 or $6? 
***** can emulate DPAPI

The pykeyctl module provides three examples. The first two are based
on the code already outlined. The third example is the
kmsresolver, which uses the ctypes wrappers in pykeyctl:
** COMMENT stupid linux tricks
hey fuzzynop
** COMMENT recap/ideas
*** COMMENT Keyctl all the things
**** avoid the paste buffer
http://www.snafu.priv.at/interests/crypto/keyutils.html
***** firefox plugin
**** iptables trick
**** bindings for every language
**** integration in to other abstraction libs
https://pypi.python.org/pypi/keyring
http://www.rubydoc.info/gems/keyring
https://github.com/atom/node-keytar
**** keyctl decrypt?
***** chain decryption internally?
**** Full implementation of DPAPI on Linux using Keyctl (for teh lawlz)
http://www.passcape.com/index.php?section=docsys&cmd=details&id=28
http://dpapick.com/
[[https://bitbucket.org/jmichel/dpapick]]
**** transparent KMS for Amazon Linux?
***** add a KMS resolver by default
***** add an easy handler
***** make magic happen
*** COMMENT Transparent KMS for Windows?
**** PAPI/CSP?
Not the focus of my talk, just an idea...
[[https://msdn.microsoft.com/en-us/library/windows/desktop/aa380245(v=vs.85).aspx]]
* history
** why was I doing this research
*** solve this problem
- I see you have a server.
- I want to hack that server.
- I find one of the more common vulnerabilities: I can read files from
  your server.
- I get your secrets. 
- I can elevate privileges and attack other services you connect to.
** what is keyctl
In every kernel since 2004...

"This service allows cryptographic keys, authentication tokens, cross-domain
user mappings, and similar to be cached in the kernel for the use of
filesystems and other kernel services."

[[/usr/src/linux-4.3/Documentation/security/keys.txt]]
*** key properties
	- A serial number.
	- [[file:/usr/src/linux-4.3/security/keys/user_defined.c::struct%20key_type%20key_type_user%20%3D%20{][A type.]] (usually [[file:/usr/src/linux-4.3/Documentation/security/keys.txt::(*)%20The%20key%20service%20defines%20three%20special%20key%20types:]["keyring", "user", "login"]])
	- [[file:/etc/request-key.conf::create%20user%20debug:*%20*%20/usr/share/keyutils/request-key-debug.sh%20%25k%20%25d%20%25c%20%25S][A description]] (for matching a key in a search).
	- Access control information.
	- An expiry time.
	- A payload.
	- [[file:/usr/src/linux-4.3/Documentation/security/keys.txt::(*)%20Each%20key%20can%20be%20in%20one%20of%20a%20number%20of%20basic%20states:][State]].
*** tracing the calls through the kernel
**** 1 [[file:/usr/src/linux-4.3/security/keys/keyctl.c::SYSCALL_DEFINE4(request_key,%20const%20char%20__user%20*,%20_type,][request_key
]](const char __user *, _type, const char __user *, _description,
const char __user *, _callout_info, key_serial_t, destringid)
***** calls [[file:/usr/src/linux-4.3/security/keys/keyctl.c::key%20%3D%20request_key_and_link(ktype,%20description,%20callout_info,][request_key_and_link]]
(struct key_type *type,
const char *description,
const void *callout_info,
size_t callout_len,
void *aux,
struct key *dest_keyring,
unsigned long flags)
****** [[file:/usr/src/linux-4.3/security/keys/request_key.c::key_ref%20%3D%20search_process_keyrings(&ctx)%3B][search_process_keyrings]]
******* 2a [[file:/usr/src/linux-4.3/security/keys/request_key.c::key_put(key)%3B][key_put]] (and stuff)
******* [[file:/usr/src/linux-4.3/security/keys/request_key.c::key%20%3D%20construct_key_and_link(&ctx,%20callout_info,%20callout_len,][construct_key_and_link]]
******** [[file:/usr/src/linux-4.3/security/keys/request_key.c::ret%20%3D%20construct_key(key,%20callout_info,%20callout_len,%20aux,][construct_key]]
********* [[file:/usr/src/linux-4.3/security/keys/request_key.c::ret%20%3D%20actor(cons,%20"create",%20aux)%3B][call_sbin_request_key]]
********** 2b [[file:/usr/src/linux-4.3/security/keys/request_key.c::ret%20%3D%20call_usermodehelper_keys(argv%5B0%5D,%20argv,%20envp,%20keyring,][call_usermodehelper_keys]]
*********** /sbin/request-key
#+name: grab_request-key_src
#+headers: :var VER="1.5.9"
#+begin_src sh
  wget "https://people.redhat.com/dhowells/keyutils/keyutils-${VER}.tar.bz2"
  tar xf "keyutils-${VER}.tar.bz2"
  echo "keyutils-${VER}"
#+end_src

#+RESULTS: grab_request-key_src
: keyutils-1.5.9
************ [[file:keyutils-1.5.9/request-key.c::int%20main(int%20argc,%20char%20*argv%5B%5D)][request_key main]]
************* 3 [[file:keyutils-1.5.9/request-key.c::static%20void%20lookup_action(char%20*op,][lookup_action]]
************** [[file:keyutils-1.5.9/request-key.c::execute_program(op,%20key,%20ktype,%20kdesc,%20callout_info,%20p)%3B][execute_program]]
*************** 4 [[file:keyutils-1.5.9/request-key.c::execv(prog,%20argv)%3B][execv the resolver]]
*************** TODO talk about [[http://www.snafu.priv.at/interests/crypto/keyutils.html][this]]
************* 5 exec from 4 inits key
******** 6 [[file:/usr/src/linux-4.3/security/keys/request_key.c::__key_link_end(dest_keyring,%20&ctx->index_key,%20edit)%3B][link the key to the keyring]]
* userland interaction
** keyctl (command line) examples
:PROPERTIES:
:comment: :session:  *eshell*
:END:
*** show keys
#+name: show_keys
#+begin_src sh :results verbatim drawer 
  keyctl show
#+end_src

#+RESULTS: show_keys
:RESULTS:
Session Keyring
 621324351 --alswrv   1000 65534  keyring: _uid_ses.1000
 159171813 --alswrv   1000 65534   \_ keyring: _uid.1000
 194043442 --alswrv   1000  1000   |   \_ user: custom:display
913276113: key inaccessible (Key has expired)
640886929: key inaccessible (Key has expired)
:END:

*** add keys
#+name: add_key
#+headers: :var NAME="test key2"
#+headers: :var DATA="this is some other data"
#+begin_src sh 
  keyctl add user "$NAME" "$DATA" @u  
#+end_src

#+name: key
#+RESULTS: add_key
: 24182866

*** show data in key
#+name: print_key
#+headers: :var KEYNUM=key
#+begin_src sh :session none :results verbatim drawer
  keyctl print $KEYNUM
#+end_src

#+RESULTS: print_key
:RESULTS:
this is some other data
:END:

*** delete key
#+name: del_key
#+headers: :var KEYNUM=key
#+begin_src sh :session none
  keyctl unlink $KEYNUM
#+end_src

#+RESULTS: del_key
: 1 links removed

*** resolve a key
#+name: resolve_key
#+headers: :var DESCRIP="debug:demo"
#+headers: :var DATA="this is some other data"
#+begin_src sh
keyctl request2 user "$DESCRIP" "$DATA"
#+end_src

#+RESULTS: resolve_key
: 189504584

#+call: print_key(KEYNUM=resolve_key)

#+RESULTS:
: Debug this is some other data

*** what else?
#+name: keyctl_functions
#+begin_src sh :results verbatim drawer
  keyctl 2>&1 | grep keyctl | cut -f4- -d' ' | grep -v -- --version
#+end_src

*** wanna know more?
#+name: rtfm
#+begin_src sh :results verbatim drawer
  man keyctl
#+end_src
#+RESULTS: rtfm
:RESULTS:
KEYCTL(1)               Linux Key Management Utilities               KEYCTL(1)

NAME
       keyctl - Key management facility control

SYNOPSIS
       keyctl --version
       keyctl show [-x] [<keyring>]
       keyctl add <type> <desc> <data> <keyring>
       keyctl padd <type> <desc> <keyring>
       keyctl request <type> <desc> [<dest_keyring>]
       keyctl request2 <type> <desc> <info> [<dest_keyring>]
       keyctl prequest2 <type> <desc> [<dest_keyring>]
       keyctl update <key> <data>
       keyctl pupdate <key>
       keyctl newring <name> <keyring>
       keyctl revoke <key>
       keyctl clear <keyring>
       keyctl link <key> <keyring>
       keyctl unlink <key> [<keyring>]
       keyctl search <keyring> <type> <desc> [<dest_keyring>]
       keyctl read <key>
       keyctl pipe <key>
       keyctl print <key>
       keyctl list <keyring>
       keyctl rlist <keyring>
       keyctl describe <keyring>
       keyctl rdescribe <keyring> [sep]
       keyctl chown <key> <uid>
       keyctl chgrp <key> <gid>
       keyctl setperm <key> <mask>
       keyctl new_session
       keyctl session
       keyctl session - [<prog> <arg1> <arg2> ...]
       keyctl session <name> [<prog> <arg1> <arg2> ...]
       keyctl instantiate <key> <data> <keyring>
       keyctl pinstantiate <key> <keyring>
       keyctl negate <key> <timeout> <keyring>
       keyctl reject <key> <timeout> <error> <keyring>
       keyctl timeout <key> <timeout>
       keyctl security <key>
       keyctl reap [-v]
       keyctl purge <type>
       keyctl purge [-i] [-p] <type> <desc>
       keyctl purge -s <type> <desc>
       keyctl get_persistent <keyring> [<uid>]

DESCRIPTION
       This  program is used to control the key management facility in various
       ways using a variety of subcommands.

KEY IDENTIFIERS
       The key identifiers passed to or returned from keyctl are, in  general,
       positive integers. There are, however, some special values with special
       meanings that can be passed as arguments:

       (*) No key: 0

       (*) Thread keyring: @t or -1

       Each thread may have its own keyring. This is  searched  first,  before
       all others. The thread keyring is replaced by (v)fork, exec and clone.

       (*) Process keyring: @p or -2

       Each  process  (thread  group) may have its own keyring. This is shared
       between all members of a group and will be searched  after  the  thread
       keyring. The process keyring is replaced by (v)fork and exec.

       (*) Session keyring: @s or -3

       Each  process  subscribes to a session keyring that is inherited across
       (v)fork, exec and clone. This is searched after  the  process  keyring.
       Session  keyrings  can  be named and an extant keyring can be joined in
       place of a process's current session keyring.

       (*) User specific keyring: @u or -4

       This keyring is shared between all the processes owned by a  particular
       user.  It  isn't  searched directly, but is normally linked to from the
       session keyring.

       (*) User default session keyring: @us or -5

       This is the default session keyring for a particular user.  Login  pro‐
       cesses that change to a particular user will bind to this session until
       another session is set.

       (*) Group specific keyring: @g or -6

       This is a place holder for a group specific keyring, but is  not  actu‐
       ally implemented yet in the kernel.

       (*) Assumed request_key authorisation key: @a or -7

       This selects the authorisation key provided to the request_key() helper
       to permit it to access the callers keyrings and instantiate the  target
       key.

       (*) Keyring by name: %:<name>

       A  named  keyring.  This will be searched for in the process's keyrings
       and in /proc/keys.

       (*) Key by name: %<type>:<name>

       A named key of the given type.   This  will  be  searched  for  in  the
       process's keyrings and in /proc/keys.

COMMAND SYNTAX
       Any  non-ambiguous  shortening of a command name may be used in lieu of
       the full command name. This facility should not be used in scripting as
       new commands may be added in future that then cause ambiguity.

       (*) Display the package version number

       keyctl --version

       This  command  prints  the  package  version  number and build date and
       exits:

              testbox>keyctl --version
              keyctl from keyutils-1.5.3 (Built 2011-08-24)

       (*) Show process keyrings

       keyctl show [-x] [<keyring>]

       By default this command recursively shows what keyrings  a  process  is
       subscribed to and what keys and keyrings they contain.  If a keyring is
       specified then that keyring will be dumped instead.  If -x is specified
       then the keyring IDs will be dumped in hex instead of decimal.

       (*) Add a key to a keyring

       keyctl add <type> <desc> <data> <keyring>
       keyctl padd <type> <desc> <keyring>

       This  command  creates  a  key  of  the specified type and description;
       instantiates it with the given data and attaches it  to  the  specified
       keyring. It then prints the new key's ID on stdout:

              testbox>keyctl add user mykey stuff @u
              26

       The  padd  variant of the command reads the data from stdin rather than
       taking it from the command line:

              testbox>echo -n stuff | keyctl padd user mykey @u
              26

       (*) Request a key

       keyctl request <type> <desc> [<dest_keyring>]
       keyctl request2 <type> <desc> <info> [<dest_keyring>]
       keyctl prequest2 <type> <desc> [<dest_keyring>]

       These three commands request the lookup of a key of the given type  and
       description. The process's keyrings will be searched, and if a match is
       found the matching key's ID will be printed to stdout; and if a  desti‐
       nation keyring is given, the key will be added to that keyring also.

       If  there  is  no  key,  the first command will simply return the error
       ENOKEY and fail. The second and third commands will  create  a  partial
       key  with  the  type and description, and call out to /sbin/request-key
       with that key and  the  extra  information  supplied.  This  will  then
       attempt to instantiate the key in some manner, such that a valid key is
       obtained.

       The third command is like the second, except that the callout  informa‐
       tion is read from stdin rather than being passed on the command line.

       If a valid key is obtained, the ID will be printed and the key attached
       as if the original search had succeeded.

       If there wasn't a valid key obtained, a temporary negative key will  be
       attached  to  the destination keyring if given and the error "Requested
       key not available" will be given.

              testbox>keyctl request2 user debug:hello wibble
              23
              testbox>echo -n wibble | keyctl prequest2 user debug:hello
              23
              testbox>keyctl request user debug:hello
              23

       (*) Update a key

       keyctl update <key> <data>
       keyctl pupdate <key>

       This command replaces the data attached to a key  with  a  new  set  of
       data.  If the type of the key doesn't support update then error "Opera‐
       tion not supported" will be returned.

              testbox>keyctl update 23 zebra

       The pupdate variant of the command reads the  data  from  stdin  rather
       than taking it from the command line:

              testbox>echo -n zebra | keyctl pupdate 23

       (*) Create a keyring

       keyctl newring <name> <keyring>

       This  command  creates a new keyring of the specified name and attaches
       it to the specified keyring. The ID of the new keyring will be  printed
       to stdout if successful.

              testbox>keyctl newring squelch @us
              27

       (*) Revoke a key

       keyctl revoke <key>

       This  command  marks  a key as being revoked. Any further operations on
       that key (apart from unlinking it) will  return  error  "Key  has  been
       revoked".

              testbox>keyctl revoke 26
              testbox>keyctl describe 26
              keyctl_describe: Key has been revoked

       (*) Clear a keyring

       keyctl clear <keyring>

       This  command  unlinks  all the keys attached to the specified keyring.
       Error "Not a directory" will be returned if the key specified is not  a
       keyring.

              testbox>keyctl clear 27

       (*) Link a key to a keyring

       keyctl link <key> <keyring>

       This command makes a link from the key to the keyring if there's enough
       capacity to do so. Error "Not a directory" will be returned if the des‐
       tination  is  not a keyring. Error "Permission denied" will be returned
       if the key doesn't have link permission or  the  keyring  doesn't  have
       write  permission.  Error "File table overflow" will be returned if the
       keyring is full. Error "Resource deadlock avoided" will be returned  if
       an attempt was made to introduce a recursive link.

              testbox>keyctl link 23 27
              testbox>keyctl link 27 27
              keyctl_link: Resource deadlock avoided

       (*) Unlink a key from a keyring or the session keyring tree

       keyctl unlink <key> [<keyring>]

       If  the  keyring  is  specified, this command removes a link to the key
       from the keyring. Error "Not a directory" will be returned if the  des‐
       tination  is  not a keyring. Error "Permission denied" will be returned
       if the keyring doesn't have write permission. Error "No  such  file  or
       directory" will be returned if the key is not linked to by the keyring.

       If  the  keyring  is not specified, this command performs a depth-first
       search of the session keyring tree and removes all  the  links  to  the
       nominated  key  that it finds (and that it is permitted to remove).  It
       prints the number of successful unlinks before exiting.

              testbox>keyctl unlink 23 27

       (*) Search a keyring

       keyctl search <keyring> <type> <desc> [<dest_keyring>]

       This command non-recursively searches a keyring for a key of a particu‐
       lar  type  and description. If found, the ID of the key will be printed
       on stdout and the key will be attached to the  destination  keyring  if
       present.  Error  "Requested  key not available" will be returned if the
       key is not found.

              testbox>keyctl search @us user debug:hello
              23
              testbox>keyctl search @us user debug:bye
              keyctl_search: Requested key not available

       (*) Read a key

       keyctl read <key>
       keyctl pipe <key>
       keyctl print <key>

       These commands read the payload of a key. "read" prints it on stdout as
       a hex dump, "pipe" dumps the raw data to stdout and "print" dumps it to
       stdout directly if it's entirely printable or as a hexdump preceded  by
       ":hex:" if not.

       If  the  key  type  does not support reading of the payload, then error
       "Operation not supported" will be returned.

              testbox>keyctl read 26
              1 bytes of data in key:
              62
              testbox>keyctl print 26
              b
              testbox>keyctl pipe 26
              btestbox>

       (*) List a keyring

       keyctl list <keyring>
       keyctl rlist <keyring>

       These commands list the contents of a key as a keyring.  "list"  pretty
       prints the contents and "rlist" just produces a space-separated list of
       key IDs.

       No attempt is made to check that the specified keyring is a keyring.

              testbox>keyctl list @us
              2 keys in keyring:
                     22: vrwsl----------  4043    -1 keyring: _uid.4043
                     23: vrwsl----------  4043  4043 user: debug:hello
              testbox>keyctl rlist @us
              22 23

       (*) Describe a key

       keyctl describe <keyring>
       keyctl rdescribe <keyring> [sep]

       These commands fetch a description  of  a  keyring.  "describe"  pretty
       prints the description in the same fashion as the "list" command; "rde‐
       scribe" prints the raw data returned from the kernel.

              testbox>keyctl describe @us
                     -5: vrwsl----------  4043     -1  keyring:  _uid_ses.4043
              testbox>keyctl                   rdescribe                   @us
              keyring;4043;-1;3f1f0000;_uid_ses.4043

       The raw string is "<type>;<uid>;<gid>;<perms>;<description>", where uid
       and  gid  are  the decimal user and group IDs, perms is the permissions
       mask in hex, type and description are the  type  name  and  description
       strings (neither of which will contain semicolons).

       (*) Change the access controls on a key

       keyctl chown <key> <uid>
       keyctl chgrp <key> <gid>

       These  two commands change the UID and GID associated with evaluating a
       key's permissions mask. The UID also governs which quota a key is taken
       out of.

       The  chown  command is not currently supported; attempting it will earn
       the error "Operation not supported" at best.

       For non-superuser users, the GID may only be set to the  process's  GID
       or a GID in the process's groups list. The superuser may set any GID it
       likes.

              testbox>sudo keyctl chown 27 0
              keyctl_chown: Operation not supported
              testbox>sudo keyctl chgrp 27 0

       (*) Set the permissions mask on a key

       keyctl setperm <key> <mask>

       This command changes the permission control mask on a key. The mask may
       be  specified  as a hex number if it begins "0x", an octal number if it
       begins "0" or a decimal number otherwise.

       The hex numbers are a combination of:

              Possessor UID       GID       Other     Permission Granted
              ========  ========  ========  ========  ==================
              01000000  00010000  00000100  00000001  View
              02000000  00020000  00000200  00000002  Read
              04000000  00040000  00000400  00000004  Write
              08000000  00080000  00000800  00000008  Search
              10000000  00100000  00001000  00000010  Link
              20000000  00200000  00002000  00000020  Set Attribute
              3f000000  003f0000  00003f00  0000003f  All

       View permits the type, description and other parameters of a key to  be
       viewed.

       Read  permits  the payload (or keyring list) to be read if supported by
       the type.

       Write permits the payload (or keyring list) to be modified or updated.

       Search on a key permits it to be found when a keyring to  which  it  is
       linked is searched.

       Link permits a key to be linked to a keyring.

       Set  Attribute  permits a key to have its owner, group membership, per‐
       missions mask and timeout changed.

              testbox>keyctl setperm 27 0x1f1f1f00

       (*) Start a new session with fresh keyrings

       keyctl session
       keyctl session - [<prog> <arg1> <arg2> ...]
       keyctl session <name> [<prog> <arg1> <arg2> ...]

       These commands join or create a new keyring and then  run  a  shell  or
       other program with that keyring as the session key.

       The  variation  with  no  arguments  just  creates an anonymous session
       keyring and attaches that  as  the  session  keyring;  it  then  exec's
       $SHELL.

       The  variation with a dash in place of a name creates an anonymous ses‐
       sion keyring and attaches that as the session keyring; it  then  exec's
       the supplied command, or $SHELL if one isn't supplied.

       The  variation  with a name supplied creates or joins the named keyring
       and attaches that as the session keyring; it then exec's  the  supplied
       command, or $SHELL if one isn't supplied.

              testbox>keyctl rdescribe @s
              keyring;4043;-1;3f1f0000;_uid_ses.4043

              testbox>keyctl session
              Joined session keyring: 28
              testbox>keyctl rdescribe @s
              keyring;4043;4043;3f1f0000;_ses.24082

              testbox>keyctl session -
              Joined session keyring: 29
              testbox>keyctl rdescribe @s
              keyring;4043;4043;3f1f0000;_ses.24139

              testbox>keyctl session - keyctl rdescribe @s
              Joined session keyring: 30
              keyring;4043;4043;3f1f0000;_ses.24185

              testbox>keyctl session fish
              Joined session keyring: 34
              testbox>keyctl rdescribe @s
              keyring;4043;4043;3f1f0000;fish

              testbox>keyctl session fish keyctl rdesc @s
              Joined session keyring: 35
              keyring;4043;4043;3f1f0000;fish

       (*) Instantiate a key

       keyctl instantiate <key> <data> <keyring>
       keyctl pinstantiate <key> <keyring>
       keyctl negate <key> <timeout> <keyring>
       keyctl reject <key> <timeout> <error> <keyring>

       These  commands  are  used to attach data to a partially set up key (as
       created by the kernel and passed to /sbin/request-key).   "instantiate"
       marks  a  key  as  being  valid  and  attaches the data as the payload.
       "negate" and "reject" mark a key as invalid and sets a timeout on it so
       that  it'll  go  away  after  a  while.  This prevents a lot of quickly
       sequential requests from slowing the system down overmuch when they all
       fail,  as  all subsequent requests will then fail with error "Requested
       key not found" (if negated) or the specified error (if rejected)  until
       the negative key has expired.

       Reject's  error  argument  can  either be a UNIX error number or one of
       'rejected', 'expired' or 'revoked'.

       The newly instantiated key will be attached to the specified keyring.

       These commands may only be run from the program run by request-key -  a
       special  authorisation  key is set up by the kernel and attached to the
       request-key's session keyring. This special key is revoked once the key
       to which it refers has been instantiated one way or another.

              testbox>keyctl instantiate $1 "Debug $3" $4
              testbox>keyctl negate $1 30 $4
              testbox>keyctl reject $1 30 64 $4

       The  pinstantiate  variant  of  the  command  reads the data from stdin
       rather than taking it from the command line:

              testbox>echo -n "Debug $3" | keyctl pinstantiate $1 $4

       (*) Set the expiry time on a key

       keyctl timeout <key> <timeout>

       This command is used to set the timeout on a key, or clear an  existing
       timeout  if the value specified is zero. The timeout is given as a num‐
       ber of seconds into the future.

              testbox>keyctl timeout $1 45

       (*) Retrieve a key's security context

       keyctl security <key>

       This command is used to retrieve a key's  LSM  security  context.   The
       label is printed on stdout.

              testbox>keyctl security @s
              unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023

       (*) Give the parent process a new session keyring

       keyctl new_session

       This command is used to give the invoking process (typically a shell) a
       new session keyring, discarding its old session keyring.

              testbox> keyctl session foo
              Joined session keyring: 723488146
              testbox> keyctl show
              Session Keyring
                     -3 --alswrv      0     0  keyring: foo
              testbox> keyctl new_session
              490511412
              testbox> keyctl show
              Session Keyring
                     -3 --alswrv      0     0  keyring: _ses

       Note that this affects the parent of the process that invokes the  sys‐
       tem  call,  and so may only affect processes with matching credentials.
       Furthermore, the change does not take effect till  the  parent  process
       next  transitions  from kernel space to user space - typically when the
       wait() system call returns.

       (*) Remove dead keys from the session keyring tree

       keyctl reap

       This command performs a depth-first  search  of  the  caller's  session
       keyring tree and attempts to unlink any key that it finds that is inac‐
       cessible due to expiry, revocation, rejection or negation.  It does not
       attempt  to  remove live keys that are unavailable simply due to a lack
       of granted permission.

       A key that is designated reapable will only be removed from  a  keyring
       if  the  caller has Write permission on that keyring, and only keyrings
       that grant Search permission to the caller will be searched.

       The command prints the number of keys reaped before it exits.   If  the
       -v  flag  is  passed  then  the reaped keys are listed as they're being
       reaped, together with the success or failure of the unlink.

       (*) Remove matching keys from the session keyring tree

       keyctl purge <type>
       keyctl purge [-i] [-p] <type> <desc>
       keyctl purge -s <type> <desc>

       These commands perform a depth-first search to find  matching  keys  in
       the  caller's  session  keyring  tree and attempts to unlink them.  The
       number of keys successfully unlinked is printed at the end.

       The keyrings must grant Read and View permission to the  caller  to  be
       searched,  and  the keys to be removed must also grant View permission.
       Keys can only be removed from keyrings that grant Write permission.

       The first variant purges all keys of the specified type.

       The second variant purges all keys of  the  specified  type  that  also
       match the given description literally.  The -i flag allows a case-inde‐
       pendent match and the -p flag allows a prefix match.

       The third variant purges all keys of the specified  type  and  matching
       description  using the key type's comparator in the kernel to match the
       description.  This permits the key type to match a key with  a  variety
       of descriptions.

       (*) Get persistent keyring

       keyctl get_persistent <keyring> [<uid>]

       This  command gets the persistent keyring for either the current UID or
       the specified UID and attaches it to the nominated keyring.   The  per‐
       sistent keyring's ID will be printed on stdout.

       The  kernel  will create the keyring if it doesn't exist and every time
       this command is called,  will  reset  the  expiration  timeout  on  the
       keyring to the value in:

              /proc/sys/kernel/keys/persistent_keyring_expiry

       (by default three days).  Should the timeout be reached, the persistent
       keyring will be removed and everything it pins can then be garbage col‐
       lected.

       If  a UID other than the process's real or effective UIDs is specified,
       then an error will be given if the process does not have the CAP_SETUID
       capability.

ERRORS
       There are a number of common errors returned by this program:

       "Not a directory" - a key wasn't a keyring.

       "Requested key not found" - the looked for key isn't available.

       "Key has been revoked" - a revoked key was accessed.

       "Key has expired" - an expired key was accessed.

       "Permission  denied" - permission was denied by a UID/GID/mask combina‐
       tion.

SEE ALSO
       keyctl(1), request-key.conf(5)

Linux                             20 Feb 2014                        KEYCTL(1)
:END:

* how the resolution system works
:PROPERTIES:
:hidesource: true
:END:
#+CAPTION: Request Key flow
#+NAME: fig:request-key
#+HEADERS: :exports results
#+begin_src ditaa :file request-key.png
  +--------------+             +---------------+           +--------------------+
  | user code    |             |     kernel    |           |  /sbin/request_key |
  +-------+------+             +-------+-------+           +---------+----------+
          |                            |                             |           
          |      1) request_key        |                             |           
          |--------------------------->|                             |           
          |                            |                             |           
          |     2a) key found          |     2b) key not found       |           
          |<---------------------------+---------------------------->|
          |                            |                             |  3) find resolver in       
          |                            |                             +---------------------------+
          |                            |                             |     /etc/request_key.conf |
          |                            |                             |                           |
          |                            |                             |                           |
          |                            |                             |                           |
          |                            |                             |<--------------------------+
          |                            |                             |                            
          |                            |                             |  4) call resolver 
          |                            |                             +---------------------------+
          |                            |                             |     to get key data       |
          |                            |                             |                           |
          |                            |                             |                           |
          |                            |                             |<--------------------------+
          |                            |    5) instantiate key       |                          
          |                            |<----------------------------+
          |                            |       with key data         |
          |   6) Return key            |                             |
          |<---------------------------+                             |
          |                            |                             |
          |                            |                             |
          |                            |                             |
          |                            |                             |

#+end_src

#+RESULTS: fig:request-key
[[file:request-key.png]]

* writing resolvers
Live demos? "KLAATU BARADA ... necktie"
#+CAPTION: evil fucking dead reference
#+NAME:   fig:evil_dead
[[./evildead.jpg]]

** debugging a resolver
*** failing resolver
[[/usr/local/sbin/failing_resolver]]
#+name: hello_resolver
#+headers: :shebang "#!/bin/bash"
#+headers: :tangle /sudo:root@localhost:/usr/local/sbin/failing_resolver
#+begin_src sh
  echo "$@" >&2
  echo "error message output" >&2
  exit 1

#+end_src
*** watch logs
**** journalctl -f in eshell
#+BEGIN_SRC emacs-lisp
(eshell  "asdf")

#+END_SRC

#+RESULTS:
: #<buffer *eshell*<3>>


**** tail -f /var/log/syslog
*** make the script
[[/sudo:root@localhost:/usr/local/sbin/debug_key_request.sh][/usr/local/sbin/debug_key_request.sh]]
#+name: debug_key_request
#+headers: :shebang "#!/bin/bash -vxxx"
#+headers: :tangle /sudo:root@localhost:/usr/local/sbin/debug_key_request.sh
#+begin_src sh
  
  LOGFILE=/tmp/request-key-debug.log
  exec 2>&1 > $LOGFILE

  PROG=$1
  shift

  echo "PWD=`pwd`"
  echo "called: $PROG $@"

  $PROG $@  >> $LOGFILE 2>&1
  cat $LOGFILE >&2
#+end_src
*** make it executable
#+name: debug_key_request_exec
#+headers: :session sudo
#+begin_src sh
  sudo chmod +x /usr/local/sbin/debug_key_request.sh
#+end_src

*** add the wrapper to [[/sudo:root@localhost:/etc/request-key.conf][/etc/request-key.conf]] 
*** run it
#+name: fail
#+headers: :session *eshell*
#+begin_src sh
  keyctl request2 user "fail:2" %u
#+end_src

#+RESULTS: fail
: request_key: Required key not available

*** check the log
[[/tmp/request-key-debug.log]]
** hello world
*** code
[[/usr/local/bin/hello_resolver]]
#+name: hello_resolver
#+headers: :shebang "#!/bin/bash"
#+begin_src sh :tangle /sudo:root@localhost:/usr/local/bin/hello_resolver
  # hello world key init
  # $0 <descrip>

  TO=$(echo $1| cut -f2 -d':')
  echo -n "hello $TO"
#+end_src

*** make it executable
#+name: make_hello_exec
#+headers: :session sudo
#+begin_src sh
  sudo chmod +x /usr/local/bin/hello_resolver
#+end_src

*** adding the resolver to request-key config
[[file:/sudo:root@localhost:/etc/request-key.conf::create%20user%20hello:*%20*%20/usr/local/bin/hello_resolver%20%25k%20%25d%20%25S][/etc/request-key.conf]]
#+begin_example
  create  user    hello:*        *                |/usr/local/bin/hello_resolver %d
#+end_example
*** <<<try hello world>>>
#+name: hello_world
#+headers: :session *eshell*
#+begin_src sh
  keyctl request2 user "hello:world" %u
#+end_src

#+name: hello_world_keynum
#+RESULTS: hello_world
: 565909212

#+name: show_hello_world
#+headers: :session *eshell*
#+headers: :var KEY=hello_world 
#+begin_src sh
  keyctl print $KEY
#+end_src

#+RESULTS: show_hello_world
|                                                                |
| > > [hex@wpad Secret Caching in the Linux Kernel]$ hello world |


#+call: del_key(KEYNUM=hello_world_keynum)

#+RESULTS:
: 1 links removed

** hello world, in python
[[/sudo:root@localhost:/usr/local/bin/hello_resolver][/usr/local/bin/hello_resolver]]
#+name: hello_resolver
#+headers: :shebang "#!/usr/bin/env python3" 
#+begin_src python :tangle /sudo:root@localhost:/usr/local/bin/hello_resolver
  from __future__ import print_function
  from sys import argv, version_info

  if version_info.major < 2:
      input = raw_input

  def main():
      descrip = argv[1].split(':')[1]
      p = ("hello %s" % descrip)
      if len(p) > 256:
          exit(1)
      print(p)

  if __name__ == "__main__":
      main()
      
#+end_src

** stored resolver
*** write the resolver
[[/usr/local/sbin/storedresolver]]
#+name: storedresolver
#+headers: :shebang "#!/usr/bin/env python"
#+headers: :tangle /sudo:root@localhost:/usr/local/sbin/storedresolver
#+begin_src python
  from __future__ import print_function

  import fcntl
  from sys import argv, version_info, stdout, stderr
  from os import getuid, chown, chmod, fstat, path
  from datetime import datetime
  from binascii import unhexlify, hexlify

  if version_info.major < 3:
      input = raw_input

  KEYSTOREFILE = "/etc/keystore"
  MAX_KEYSIZE = 1024*1024 


  ###############################################################################


  class KeyStoreEntry:

      def __init__(self, uid, key, timestamp):
          self.uid = int(uid)
          self.key = unhexlify(key)
          self.time = datetime.fromtimestamp(int(timestamp))

      def __repr__(self):
          return "<KeyStoreEntry '%s'>" % self

      def __str__(self):
          return "%s %s %s" % (self.uid,
                               hexlify(self.key).decode('ascii'),
                               int(self.time.timestamp()))


  class KeyStore:

      def __init__(self, keystore, key_size):
          self.fd = None
          self.entries = []
          self.key_size = int(key_size)
          assert self.key_size <= MAX_KEYSIZE, "Key size too big"
          if not path.exists(keystore):
              with open(keystore,'x') as touch:
                  touch.write('')
              chown(keystore, 0, 0)
              chmod(keystore, 0o600)
          self.fd = open(keystore, 'r+')
          s = fstat(self.fd.fileno())
          fcntl.lockf(self.fd, fcntl.LOCK_EX)
          assert (s.st_uid == 0 and
                  s.st_gid == 0 and
                  not ((s.st_mode & 0o7777) ^ 0o0600)),\
              "Invalid permissions on %s" % keystore
          for line in self.fd:
              uid, key, timestamp = line.split(' ')
              self.entries.append(KeyStoreEntry(uid, key, timestamp))

      def add_key_for(self, uid):
          with open('/dev/urandom','rb') as r:
              key = r.read(self.key_size)
          self.entries.append(KeyStoreEntry(uid,
                                            hexlify(key),
                                            datetime.now().timestamp()))
          return key

      def __getitem__(self, uid):
          try:
              return next(e.key for e in self.entries if e.uid == uid
                          and len(e.key) == self.key_size)
          except StopIteration:
              key = self.add_key_for(uid)
              self.write()
              return key

      def write(self):
          self.fd.seek(0)
          self.fd.write("\n".join("%s" % k for k in self.entries)) 

      def __del__(self):
          if self.fd:
              fcntl.lockf(self.fd, fcntl.LOCK_UN)
              self.fd.close()

          
  ###############################################################################

  def usage():
      print("This program should never be run on it's own and will only work if "
            "run as root. It is intended to be run by the request-key process.",
            file=stderr)
      print("it's correct usage is:", file=stderr)
      print("%s <uid> <gid>" % argv[0], file=stderr)
      exit(1)


  def find_or_make_key(uid, key_size):
      keystore = KeyStore(KEYSTOREFILE, key_size)
      payload = keystore[uid]
      del(keystore)
      return payload
      
      
  def main():
      if (getuid() != 0) or (len(argv) < 3):
          usage()
      uid = int(argv[1])
      gid = int(argv[2])
      key_size = input()

      payload = find_or_make_key(uid, key_size)
      stdout.buffer.write(payload)

  if __name__ == "__main__":
      main()
#+end_src
*** configure request-key
[[file:/sudo:root@localhost:/etc/request-key.conf::create%20user%20stored:*%20*%20/usr/local/sbin/storedresolver%20%25k%20%25u%20%25g%20%25S%20%25c][/etc/request-key.conf]]

#+begin_example
  create  user    stored:*        *               |/usr/local/sbin/storedresolver %u %g
#+end_example
*** PoC 
**** create key
#+name: create_stored_demo
#+headers: :var ID="demo"
#+begin_src sh 
  keyctl request2 "user" "stored:$ID" "32" 
#+end_src

#+RESULTS: create_stored_demo
: 846204826

**** print key
#+name: print_stroed_demo
#+headers: :var KEYNUM=create_stored_demo()
#+begin_src sh 
  keyctl print $KEYNUM
#+end_src

#+RESULTS: print_stroed_demo
: :hex:456d2bfa281acdb36d46045d97b4ce2c3135149d000ba9fa965280644d166e83

**** "reboot"
#+name: demo_reboot
#+headers: :var KEYNUM=create_stored_demo()
#+begin_src sh :results verbatim drawer 
  keyctl show
  old_key=$(keyctl print $KEYNUM)
  keyctl unlink $KEYNUM
  keyctl show
  key=$(keyctl request2 "user" "stored:demo" "32" )
  new_key=$(keyctl print $key)
  echo old key = $old_key
  echo new key = $new_key
#+end_src

#+RESULTS: demo_reboot
:RESULTS:
Session Keyring
 621324351 --alswrv   1000 65534  keyring: _uid_ses.1000
 159171813 --alswrv   1000 65534   \_ keyring: _uid.1000
 194043442 --alswrv   1000  1000   |   \_ user: custom:display
1015649794 --alswrv   1000  1000   \_ user: stored:demo13
 185483047 --alswrv   1000  1000   \_ user: stored:demo11
 214841598 --alswrv   1000  1000   \_ user: stored:demo10
 290832808 --alswrv   1000  1000   \_ user: stored:demo
 133222334 --alswrv   1000  1000   \_ user: stored:demo15
 160224077 --alswrv   1000  1000   \_ user: hello:world
1 links removed
Session Keyring
 621324351 --alswrv   1000 65534  keyring: _uid_ses.1000
 159171813 --alswrv   1000 65534   \_ keyring: _uid.1000
 194043442 --alswrv   1000  1000   |   \_ user: custom:display
1015649794 --alswrv   1000  1000   \_ user: stored:demo13
 185483047 --alswrv   1000  1000   \_ user: stored:demo11
 214841598 --alswrv   1000  1000   \_ user: stored:demo10
 133222334 --alswrv   1000  1000   \_ user: stored:demo15
 160224077 --alswrv   1000  1000   \_ user: hello:world
old key = :hex:456d2bfa281acdb36d46045d97b4ce2c3135149d000ba9fa965280644d166e83
new key = :hex:456d2bfa281acdb36d46045d97b4ce2c3135149d000ba9fa965280644d166e83
:END:

** TODO KMS resolver
fix this to use stdin/out
[[/usr/bin/kmsresolver]]
#+name: kmsresolver
#+headers: :shebang "#!/usr/bin/env python"
#+headers: :tangle /sudo:root@localhost:/usr/bin/kmsresolver
#+begin_src python 
  from __future__ import print_function
  from sys import argv
  from os import setuid, setgid, getuid

  def usage():
      print("This program should never be run on it's own and will only work if "
            "run as root. It is intended to be run by the request-key process." )
      print("it's correct usage is:")
      print("%s <key> <uid> <gid> <keyring> <base64_encoded_encrypted_key>" % argv[0])
      exit(1)

  def decrypt_key(b64_key):
      from base64 import b64decode
      import boto
      key_data = b64decode(b64_key)
      print("key data type %s, data: %s" % (type(key_data), key_data))
      kms = boto.connect_kms()
      decrypted_blob = kms.decrypt(key_data)
      return bytes(decrypted_blob["Plaintext"])

  def main():
      if (getuid() != 0) or (len(argv) < 5):
          usage()
      uid = int(argv[2])
      gid = int(argv[3])
      setgid(gid)
      setuid(uid)
      keyid = int(argv[1])
      keyring = int(argv[4])

      from keyctl import Key #only import other deps after we've dropped privs
      b64_key = argv[5]
      print(type(b64_key))
      payload = decrypt_key(b64_key)
      k = Key(keyid)
      k.instantiate(payload, keyring)

      
  if __name__ == "__main__":
      main()
#+end_src
**** walkthrough
Set up two instances to use KMS keys and create a key that's shared
between the instances. A Detailed walk through of this process is
beyond the scope of this document.
***** Install deps
#+begin_src sh
  sudo aptitude update
  sudo aptitude install python-pip keyutils
  sudo pip install boto
  git clone https://github.com/jdukes/pykeyctl
  cd pykeyctl #change this to pip install
  sudo python setup.py install
#+end_src
***** Verify instance access to the key
[[verify_key_access.py]]
#+begin_src python :tangle verify_key_access
  import boto
  import base64

  KEYID = "bdf4f9ea-0578-4ac5-a807-7a62bb60ec5e" 
  kms = boto.connect_kms()
  dk = kms.generate_data_key_without_plaintext(KEYID, number_of_bytes=1024)
  b64dk = base64.b64encode(dk['CiphertextBlob'])
  print(b64dk)

  # CiCJNTYy2Iiu3nUbzGxoQI4qntX9/6HqdMgNysn/PeAK6BKRCQEBAQB4iTU2MtiIrt51G8xsaECOKp7V/f+h6nTIDcrJ/z3gCugAAARoMIIEZAYJKoZIhvcNAQcGoIIEVTCCBFECAQAwggRKBgkqhkiG9w0BBwEwHgYJYIZIAWUDBAEuMBEEDFlOtbQ5NAR46aZoMgIBEICCBBvRIeF7DKAgEjVB1vwSX6GagimkjUi58c8it4AmgaKq2KzXF+AsjiLHreNiDcD5a1RR0NH4UfkcEtK5DODEfj4yDrp+vfUTI8CLz2vQwvulUy6c24xLblAuBcA5k/CWxSiULfBetM/UzWjVIMS0bwBo1oIDjp98o/xw9mq3tWiakUDW2Ii6Bcuv9xc4eAk9C/faKizmgqI+BIEof8+Zl7HGbYIdqxy4dkwW1r3yVZ7GllGYwPJuo2O/qJrvCBafR/UzbCEFGvrzoI3HygQQ844t7EdrQGPw18zUSc0A46Va2NphAOMZsehJkrXt31TpGNXRMgKxYIrQe0gbvq2qPOjo4fBh5DM5V5MeceXo7axu52xvMYhgumCIIoMfjmLHwRVMU5ekWEfNbt8YdB7kUsWEobEh+a2JjDrbQFEZTB63pDR1XKjGZT/pfApdwAemKUoxOdZupbzF6xaadVreDmIG1Hen/g0arj4QLSfDtzm91svRc6x9J8O5WOwAjWJUIx0dg6NUKhGRp1jhtRYOXayPUrOQcS8nIWYo2SXoh5cip6A1cSzRTLw8C3VdpnaBleTqLf8vOAkZo0VaajWSWTk6GvKCtJOaOdNjA9nBsZl86ntqxqhc+7JmTYDjKxBFypgbTX3Mu19Qd0CZMSN2OJIQkd1rRiESXIJm6lMtBqMmywWwTN5AhIFTaxQntDGpucRX544VZg53jB/VZv23DcW1rSWnl5y6HEwOvVWsmhxV0zeWNtDBjvZVQlX1M3GnakwrlEmqhhHFmHIIUUWzxGdJu6zCRGLBs8lxtGGbXtxdDGw6V/fXwTdU210eCDkawfUHvP+4uHZxwl4acDovvP1IrQSN+Eh6NmiOg6860M6eDE3H6KnbyhbJAnMZ5PgPzUYfWa37WAd1c9prg9yeMcCJLAi7SI+M9K68heLVuH8eVPEi6CaUo5E0du6OlkbvWyiR8x9yDicsmqhNQWqCch5k0RQkqlfSEH06bH5z/q8/jfyf+ngz+v59SR+UicBchX2sTGoi6QTUpxHXPzFwQZHeEwoA/RFR9swsk5l2OIVoxfRHCVbN5Ykq2rsicsc5iOXK5tYpvwAqH8x11sF/jNIeczbWQHvHi61YouxE3YjkLxtA3/Q7H+ooW4W1M55x82ylsUHysREDeep6iE3X3JBKoOBJ5GSEkEXw8jP43pnW4fv/9z2VcTi30oVj6AWnQF/LT1dw00K7UxRsNCTCPxnRHdGdP5J3E+vMQ4F3VymDUj9Zb+OIJG0u03W0sqfpEARc77ximPZl9yzUJWdOI6KbLz5J8wC3WJQp3Jd1zplhXnozkN8ltpu8BASLCpiiDoFaw3VeGqZgw5dn6n7QP2COhCMFczmUrS7lO231BGVzS8aER0/UJRBQ/A6p

  kms.decrypt(base64.b64decode(b64dk))["Plaintext"]
#+end_src
***** set up the kms resolver
[[/sudo:root@localhost:/etc/request-key.conf][/etc/request-key.conf]]
#+begin_example
  create  user    kms:*           *               /usr/local/bin/kmsresolver %k %u %g %S %c
#+end_example
***** encrypt secrets on a master system
[[encrypt_secret.py]]
#+begin_src python :tangle encrypt_secret
  import boto
  import base64

  KEYID = "bdf4f9ea-0578-4ac5-a807-7a62bb60ec5e" 
  kms = boto.connect_kms()
  key_data = kms.encrypt(KEYID, "my key for encrypting user secrets")
  b64data = base64.b64encode(key_data['CiphertextBlob'])
  print(b64data)
  # CiCJNTYy2Iiu3nUbzGxoQI4qntX9/6HqdMgNysn/PeAK6BKpAQEBAgB4iTU2MtiIrt51G8xsaECOKp7V/f+h6nTIDcrJ/z3gCugAAACAMH4GCSqGSIb3DQEHBqBxMG8CAQAwagYJKoZIhvcNAQcBMB4GCWCGSAFlAwQBLjARBAxgnhkdQEiHWOWt38YCARCAPfdv5IqdB3vElG4gISb5fVXeXpkb976Nvgh10Qnz1LDvB4W9d5+LEAIr7XNMHpwzm0ufl73VuUD//5cZeho=
#+end_src
***** Include the encrypted data in source
[[demoapp.py]]
#+begin_src python :tangle demoapp
  from keyctl import Key

  b64data = b"CiCJNTYy2Iiu3nUbzGxoQI4qntX9/6HqdMgNysn/PeAK6BKpAQEBAgB4iTU2MtiIrt51G8xsaECOKp7V/f+h6nTIDcrJ/z3gCugAAACAMH4GCSqGSIb3DQEHBqBxMG8CAQAwagYJKoZIhvcNAQcBMB4GCWCGSAFlAwQBLjARBAxgnhkdQEiHWOWt38YCARCAPfdv5IqdB3vElG4gISb5fVXeXpkb976Nvgh10Qnz1LDvB4W9d5+LEAIr7XNMHpwzm0ufl73VuUD//5cZeho="

  k = Key.request(b"kms:mykey", callout_info=b64data)
  print(k.read())
  # "my key for encrypting user secrets"
#+end_src
* stupid linux tricks
** password manager that doesn't use the paste buffer
http://www.snafu.priv.at/interests/crypto/keyutils.html

** iptables by user
** yubi-key/hardware backed resolver
* recap/ideas
** userland
keyctl
** everything else
- https://github.com/jdukes/pykeyctl
* questions


